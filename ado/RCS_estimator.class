*Class for Estimators for the Rapid Consumption Survey simulations
version 14.2

class RCS_estimator {
	double nmi
	double nmodules
	double pq
	string model
	string logmodel
	string minmodel
	string weight
	string hhmod
	string cluster
	string register
	double init = 0
}
program .new
	*check whether package is installed
	capture : which vselect
	if (_rc) {
		display as result in smcl `"Please install package {it:vselect} from SSC in order to run this do-file;"' _newline `"you can do so by clicking this link: {stata "ssc install vselect":auto-install vselect}"'
		exit 199
	}
	capture : which esttab
	if (_rc) {
		display as result in smcl `"Please install package {it:st0085_2} for esttab from SSC in order to run this do-file;"' _newline `"you can do so by clicking this link: {stata "net install st0085_2.pkg":net install st0085_2.pkg, from(http://www.stata-journal.com/software/sj14-2/)}"'
		exit 199
	}
end
* prepares estimator by selecting best model
* parameters:
*    hhid: household id variable names
*    weight: variable name of the weight variable
*    hhmod: variable name of the module assignment of the household
*    cluster: variable name for clusters
*    xfcons: variable name stub for food consumption module, e.g. xfcons for xfcons0, xfcons1, ...
*    xnfcons: variable name stub for non-food consumption module, e.g. xnfcons for xnfcons0, xnfcons1, ...
*    [nmi]: number of imputations (default: 1)
program .prepare
	syntax , hhid(varlist) weight(varname) hhmod(varname) cluster(varname) xfcons(name) xnfcons(name) [nmi(integer 1)]
	.hhid = "`hhid'"
	.weight = "`weight'"
	.hhmod = "`hhmod'"
	.cluster = "`cluster'"
	quiet: levelsof `hhmod', local(modules)
	.nmodules = max(`: subinstr local modules " " ",", all')
	.xfcons = "`xfcons'"
	.xnfcons = "`xnfcons'"
	.nmi = `nmi'
	*check whether variables are correctly given
	quiet: duplicates tag `hhid', generate(dtag)
	quiet: count if dtag>0
	if r(N)>0 {
		di as error "RCS_estimator.prepare: variables in hhid (set to `hhid') must uniquely identify records."
		error 1
	}
	drop dtag
	forvalues imod = 0/`.nmodules' {
		capture: confirm var `.xfcons'`imod'
		if _rc>0 {
			di as error "RCS_estimator.prepare: Can't find variable `.xfcons'`imod'. Check name of stub for food module consumption."
			error 1
		}
		capture: confirm var `.xnfcons'`imod'
		if _rc>0 {
			di as error "RCS_estimator.prepare: Can't find variable `.xnfcons'`imod'. Check name of stub for non-food module consumption."
			error 1
		}
	}
	*prepare quartiles for core consumption
	foreach v of var `.xfcons'0 `.xnfcons'0 {
		xtile _p`v' = `v' [pweight=`.weight'] , n(4)
		label var _p`v' "Quartiles for `: var label `v''"
	}
	.init=1
end
* prepares estimator by selecting best model
* parameters:
*    [varlist]: variables to be included in model selection. Do not use i. notation, but apply xi before.
*    fix: variable list of variables to always include into the model model selection
*    [model]: variable list for the model
*    [logmodel]: variable list of the log model
* notes:
*    either varlist or model and logmodel must be defined
program define .select_model
	syntax [varlist(fv)], [fix(varlist fv) model(varlist fv) logmodel(varlist fv) method(namelist min=1 max=2)]
	*check parameters
	if ("`varlist'"=="") & (("`model'"=="") | ("`logmodel'"=="")) {
		di as error "RCS_estimator.select_model: either variable list for model, or model and logmodel must be defined."
		error 1
	}
	if ("`method'"=="") local method = "forward aicc"
	if !inlist("`: word 1 of `method''","forward","backward","best") {
		di as error "RCS_estimator.select_model: method for variable selection must be either 'forward', 'backward' or 'best'."
		error 1
	}
	*get model, save specification in local macros model and logmodel
	di "Obtaining model structure ..."
	quiet {
		*as model selection can take some time for many variables, we use first simulation only
		*but model selection is robust against using different simulations
		egen model = rowtotal(`.xfcons'* `.xnfcons'*)
		gen logmodel = ln(model)
		replace logmodel = ln(.01) if missing(logmodel)
		foreach m in model logmodel {
			if ("``m''"=="") {
				xi: vselect `m' `varlist' [pweight=`.weight'], `method' fix("`fix' i.`.hhmod'")
				if ("`: word 1 of `method''"=="best") {
					matrix A = r(info)
					matrix B = A[1...,colnumb("A","k")],A[1...,colnumb("A","AICC")]
					vselect_best "B"
					.`m' = "`fix' i._p`.xfcons'0 i._p`.xnfcons'0 `r(best)'"
				}
				else .`m' = "`fix' i._p`.xfcons'0 i._p`.xnfcons'0 `r(predlist)'"
			}
			else {
				.`m' = "``m''"
			}
			*get model without core percentiles
			local tmodel = "`.`m''"
			local mymodel : subinstr local tmodel "i._p`.xfcons'0" "", all
			local mymodel : subinstr local mymodel "i._p`.xnfcons'0" "", all
			*****************************************
			*output regression
			eststo: quietly reg `m' `mymodel' i.`.hhmod' [pweight=`.weight']
			esttab , r2 ar2 aic
			drop `m'
		}
		.minmodel = "`fix' i._p`.xfcons'0 i._p`.xnfcons'0"
	}
	*prepare variable registration for mi
	local model = "`.model'"
	local logmodel = "`.logmodel'"
	local smodel : subinstr local model "i." "", all
	local slogmodel : subinstr local logmodel "i." "", all
	local register = "`smodel' `slogmodel'"
	.register = "`: list uniq register'"
	.init=2
end
*parameters:
*  method: name of the method to estimate
*  pq: only needed for swift2: ratio of sample with full consumption
program define .estimate
	syntax , method(string) [pq(real -1.0)]
	.pq = `pq'
	*save dataset to restore afterwards
	tempfile fh
	unab x_order : *
	quiet: save "`fh'", replace
	*prepare estimation
	*create quartiles for consumption
	quiet foreach v of var `.xfcons'0 `.xnfcons'0 {
		xtile _p`v' = `v' [pweight=`.weight'] , n(4)
		label var _p`v' "Quartiles for `: var label `v''"
	}
	*run estimation and store results
	.est_`method'
	*add original file variables
	quiet: merge 1:1 `.hhid' using "`fh'", nogen assert(match)
	order `x_order', first
end

*******************************
* single imputation functions *
*******************************

*use the average to estimate missing consumption
program define .est_avg
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	*start estimation
	quiet: forvalues imod = 1/`.nmodules' {
		egen avg_xfcons`imod' = mean(xfcons`imod')
		replace xfcons`imod' = avg_xfcons`imod' if xfcons`imod'>=.
		egen avg_xnfcons`imod' = mean(xnfcons`imod')
		replace xnfcons`imod' = avg_xnfcons`imod' if xnfcons`imod'>=.
	}
	drop avg_x*
end

*use the median to estimate missing consumption
program define .est_med
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	*start estimation
	quiet: forvalues imod =1/`.nmodules' {
		egen avg_xfcons`imod' = median(xfcons`imod')
		replace xfcons`imod' = avg_xfcons`imod' if xfcons`imod'>=.
		egen avg_xnfcons`imod' = median(xnfcons`imod')
		replace xnfcons`imod' = avg_xnfcons`imod' if xnfcons`imod'>=.
	}
	drop avg_x*
end

*use the tobit to estimate missing consumption
program define .est_tobit
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	*start estimation
	quiet forvalues imod =1/`.nmodules' {
		*food
		capture: tobit xfcons`imod' `.model' i.`.cluster' [aweight=`.weight'], ll(0) tolerance(1e-4) ltolerance(1e-5)
		local rc = _rc
		if ~e(converged) di as error "RCS_estimator.est_tobit didn't converge for food module `imod'."
		*if insufficient sample size, remove cluster variables
		if (`rc' == 2000) {
			tobit xfcons`imod' `.model' [aweight=`.weight'], ll(0)
			if ~e(converged) di as error "RCS_estimator.est_tobit didn't converge for food module `imod' without cluster variables."
		}
		predict y`imod' if xfcons`imod'>=.
		replace xfcons`imod' = max(y`imod',0) if missing(xfcons`imod')
		drop y`imod'
		*non-food
		capture: tobit xnfcons`imod' `.model' i.`.cluster' [aweight=`.weight'], ll(0) tolerance(1e-4) ltolerance(1e-5)
		local rc = _rc
		if ~e(converged) di as error "RCS_estimator.est_tobit didn't converge for non-food module `imod'."
		if (`rc' == 2000) {
			tobit xnfcons`imod' `.model' [aweight=`.weight'], ll(0)
			if ~e(converged) di as error "RCS_estimator.est_tobit didn't converge for non-food module `imod' without cluster variables."
		}
		predict y`imod' if missing(xnfcons`imod')
		replace xnfcons`imod' = max(y`imod',0) if xnfcons`imod'>=.
		drop y`imod'
	}
end

*use the regression to estimate missing consumption
program define .est_reg
	syntax , [log]
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	*start estimation
	quiet: forvalues imod =1/`.nmodules' {
		if ("`log'"!="") {
			replace xfcons`imod' = log(xfcons`imod')
			replace xnfcons`imod' = log(xnfcons`imod')
		}
		*food
		reg xfcons`imod' `.model' [aweight=`.weight']
		predict y if xfcons`imod'>=.
		replace xfcons`imod' = max(y,0) if xfcons`imod'>=.
		drop y
		*non-food
		reg xnfcons`imod' `.model' [aweight=`.weight']
		predict y if xnfcons`imod'>=.
		replace xnfcons`imod' = max(y,0) if xnfcons`imod'>=.
		drop y
		if ("`log'"!="") {
			replace xfcons`imod' = exp(xfcons`imod')
			replace xnfcons`imod' = exp(xnfcons`imod')
		}
	}
end

*********************************
* multiple imputation functions *
*********************************

*use Multi-variate normal imputation using MCMC
program define .est_mi_mvn
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	*run MI
	quiet {
		mi set wide
		mi register imputed xfcons* xnfcons*
		mi register regular `.register'
		mi impute mvn xfcons* xnfcons* = `.model', add(`.nmi') burnin(1000)
	}
end

*using chained equations
program define .est_mi_ce
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	*run MI
	quiet {
		mi set wide
		mi register imputed xfcons* xnfcons*
		mi register regular `.register'
		mi impute chained (regress) xfcons* xnfcons* = `.model', add(`.nmi') report
	}
end

*log regressions with multiple imputations
program define .est_mi_regl
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	.est_mi_reg , log
end

*truncated regressions with multiple imputations
program define .est_mi_treg
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	.est_mi_reg , reg(truncated)
end

*truncated regressions with multiple imputations
program define .est_mi_2ce
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	.est_mi_reg , reg(twostep)
end

*truncated regressions with multiple imputations
program define .est_mi_2cel
	syntax
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	.est_mi_reg , log reg(twostep)
end

*regression but with multiple imputations
* parameters:
*   regfunc: normal or truncated or twostep: 
*      normal: standard regression
*      truncated: use regression truncated at 0
*      twostep: use a two-step MICE approach to predict consumption based on whether consumed
program define .est_mi_reg
	syntax , [log REGfunc(string)]
	if (`.init' < 2) {
		di as error "RCS_estimator must be initialized using .prepare and .select_model before running estimations."
		error 1
	}
	if ("`regfunc'"=="") local regfunc = "normal"
	if !inlist("`regfunc'","normal","truncated","twostep") {
		di as error "In RCS_estimate_mi_reg the parameter 'regfunc' must be 'normal', 'truncated' or 'twostep'."
		error 1
	}
	if ("`regfunc'"=="truncated") & ("`log'"!="") {
		di as error "In RCS_estimate_mi_reg, function cannot be called in truncated option with log switched on."
		error 1
	}
	quiet {
		cap: drop xfitem*
		cap: drop xnfitem*
		cap: drop bfitem*
		cap: drop bnfitem*
		* reshape to long format
		ren (`.xfcons'0 `.xnfcons'0) (fcore nfcore)
		ren (`.xfcons'* `.xnfcons'*) (y1* y0*)
		reshape long y0 y1, i(`.hhid') j(imod)
		reshape long y, i(`.hhid' imod) j(food)
		*remember 0 consumption
		gen y_0 = y==0 if !missing(y)
		if ("`log'"!="") {
			*regularize for zero consumption
			replace y = .01 if y<=0
			replace y = ln(y)
		}
		*run MI
		mi set wide
		mi register imputed y y_0
		mi register regular imod food
		mi register regular `.register'
		*run ols or truncated regression
		if ("`regfunc'"=="normal") {
			mi impute regress y = `.`log'model', add(`.nmi') by(imod food)
		}
		else if ("`regfunc'"=="truncated") {
			*replace zeros as they cannot be considered in the regression (can't be called as log)
			summ y if y>0
			replace y = r(min) if y==0
			mi impute truncreg y = `.model', ll(0) add(`.nmi') by(imod food) force
			mi xeq: replace y = 0 if missing(y) | y_0
		}
		else if ("`regfunc'"=="twostep") {
			*step conditional step if almost all hh have module consumption >0
			levelsof imod, local(lmod)
			local add = "add(`.nmi')"
			forvalues food = 0/1 {
				foreach imod of local lmod {
					count if (y_0==1) & ((imod==`imod') & (food==`food'))
					if r(N)>5 {
						capture: mi impute monotone (logit, augment) y_0 (reg, cond(if y_0==0)) y = `.`log'model' if imod==`imod' & food==`food', `add'
						local r= _rc
						if inlist(`r',111,430,498,2000,3301,3621) {
							capture: mi impute monotone (logit y_0 `.minmodel', augment) (reg y `.`log'model', cond(if y_0==0)) if imod==`imod' & food==`food', custom `add'
							local r= _rc
							if inlist(`r',111,430,498,2000,3301,3621) {
								mi impute monotone (logit y_0 `.minmodel', augment) (reg y `.minmodel', cond(if y_0==0)) if imod==`imod' & food==`food', custom `add'
							}
							else if `r'>0 {
								di as error "Error (`r') in mi_2cel estimation (2nd level) with imod=`imod' and food=`food':"
								noisily: tab y_0 if ((imod==`imod') & (food==`food'))
								error `r'
							}
						}
						else if `r'>0 {
							di as error "Error (`r') in mi_2cel estimation (1st level) with imod=`imod' and food=`food':"
							noisily: tab y_0 if ((imod==`imod') & (food==`food'))
							error `r'
						}
					}
					else {
						capture: mi impute reg y = `.`log'model' if imod==`imod' & food==`food', `add'
						local r= _rc
						if inlist(`r',111,430,498,2000,3301,3621) {
							mi impute reg y = `.minmodel' if imod==`imod' & food==`food', `add'
						}
						else if `r'>0 {
							di as error "Error (`r') in mi_2cel estimation (n<5) with imod=`imod' and food=`food':"
							noisily: tab y_0 if ((imod==`imod') & (food==`food'))
							error `r'
						}
					}
					local add = "replace"
				}
			}
		}
		*transform into household-level dataset
		keep `.hhid' y y_0 _* imod food fcore nfcore
		if ("`log'"!="") mi passive: gen z = exp(y)
		else mi passive: gen z = y
		*reshape back to the hh-level
		mi passive: replace z = 0 if y_0==1
		drop y_0 y
		mi register imputed z
		mi update
		mi reshape wide z, i(`.hhid' imod) j(food)
		mi rename z0 xnfcons
		mi rename z1 xfcons
		mi reshape wide `.xfcons' `.xnfcons', i(`.hhid') j(imod)
		mi ren fcore `.xfcons'0
		mi ren nfcore `.xnfcons'0
	}
end

*******************************
* other methods like swift    *
*******************************

program define .est_swift2
	syntax
	*select full consumption subset
	gen sample = runiform()
	replace sample = sample<`.pq'
	gen icons = ln(ccons) if sample
	*impute for non-subset
	mi set wide
	mi register imputed icons
	mi register regular `.register'
	*run ols 
	mi impute regress icons = `.logmodel', add(`.nmi')
	mi passive: gen xcons = exp(icons)
end

*code to estimate items rather than modules

*use mi to estimate missing consumption, all items at once
program define .est_xmi
	*calculating number of consumed items
	egen n1 = rowtotal(bfitem*)
	gen n1sq = n1*n1
	egen n2 = rowtotal(bnfitem*)
	gen n2sq = n2*n2
	* renaming
	rename xfitem* x1*
	rename xnfitem* x2*
	rename bfitem* c1*
	rename bnfitem* c2* 
	* reshape to long format
	qui reshape long x c, i(`.hhid') j(item)
	replace x = . if !c
	replace x = log(x) if c
	*flag for food items
	gen food = floor(item/(10^floor(log10(item))))==1
	*calculate probability of b for each item
	gen b = ~missing(x) if c
	bysort item: egen nb = total(b)
	bysort item: egen ncb = count(b)
	gen pb = nb/ncb
	drop nb ncb
	* estimate, predict, impute
	*run MI
	mi set wide
	mi register imputed x
	mi register regular n1 n1sq n2 n2sq pb c
	mi register regular `.register'
	mi impute regress x = n1 n1sq n2 n2sq pb, add(`.nmi') conditional(c==1) by(item)
	*transform into household-level dataset
	keep `.hhid' y _* item c
	mi passive: gen z = exp(y) if c
	mi passive: replace z = 0 if !c
	*reshape back to the hh-level
	drop x
	mi register imputed z
	mi update
	*sum at the hh-level
	mi convert flongsep _rcs_xmi, clear
	mi xeq: by `.hhid', sort: egen z_sum = total(z)
	*maintain mi consistency
	mi xeq 0: gen Mis_z = (z==.) ; by `.hhid', sort: egen Mis_total = total(Mis_z) ; replace z_sum = . if Mis_total>0
	*only keep hh-level records
	mi xeq: sort `.hhid' item; by `.hhid': drop if _n>1 ; drop item z Mis_z Mis_total ; ren z_sum xfcons1
	mi register imputed xfcons1
	mi convert wide, clear
	mi erase _rcs_ri_mi_par
	*note that we stop distinguishing between food and non-food here (for computational efficiencies)
	gen xnfcons1 = 0
	*all consumption is collected in module 1; thus, need to set module 0 to be zero
	gen xfcons0 = 0
	gen xnfcons0 = 0
end
